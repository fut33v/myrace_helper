#!/usr/bin/env python3
"""Convert browser-exported JSON cookies to Netscape format."""

from __future__ import annotations

import argparse
import json
from pathlib import Path
from typing import Iterable, List, Tuple


def parse_args() -> argparse.Namespace:
    parser = argparse.ArgumentParser(
        description="Преобразует JSON cookies (например, из браузера) в формат Netscape."
    )
    parser.add_argument(
        "--input",
        "-i",
        default="cookies_browser.json",
        help="Путь к JSON-файлу, экспортированному из браузера (по умолчанию cookies_browser.json).",
    )
    parser.add_argument(
        "--output",
        "-o",
        default="cookies/myrace_cookies.txt",
        help="Файл вывода в Netscape формате (по умолчанию cookies/myrace_cookies.txt).",
    )
    parser.add_argument(
        "--append",
        action="store_true",
        help="Добавить cookies к уже существующему файлу (иначе файл будет перезаписан).",
    )
    return parser.parse_args()


def load_json(path: Path) -> List[dict]:
    try:
        with path.open("r", encoding="utf-8") as handle:
            data = json.load(handle)
    except json.JSONDecodeError as exc:
        raise RuntimeError(f"Некорректный JSON в {path}: {exc}") from exc
    if isinstance(data, dict):
        cookies = data.get("cookies")
        if not isinstance(cookies, list):
            raise RuntimeError("Ожидался массив cookies или объект с полем cookies[].")
        return cookies
    if isinstance(data, list):
        return data
    raise RuntimeError("JSON должен содержать массив объектов cookie.")


def to_netscape_lines(cookies: Iterable[dict]) -> List[str]:
    lines: List[str] = [
        "# Netscape HTTP Cookie File",
        "# This file was generated by convert_cookies.py",
    ]
    for item in cookies:
        domain = str(item.get("domain", "")).strip()
        if not domain:
            continue
        host_only = bool(item.get("hostOnly", False))
        http_only = bool(item.get("httpOnly", False))
        secure = bool(item.get("secure", False))
        path = item.get("path") or "/"
        name = item.get("name")
        value = item.get("value", "")
        if not name:
            continue
        session = bool(item.get("session", False))
        expiration = item.get("expirationDate")
        if session or expiration is None:
            expires = 0
        else:
            try:
                expires = int(expiration)
            except (TypeError, ValueError):
                expires = 0

        tailmatch = "FALSE" if host_only else "TRUE"
        secure_flag = "TRUE" if secure else "FALSE"

        domain_output = domain if host_only else domain.lstrip(".")
        if not host_only and not domain_output.startswith("."):
            domain_output = "." + domain_output
        if http_only:
            domain_output = "#HttpOnly_" + domain_output

        line = "\t".join(
            (
                domain_output,
                tailmatch,
                path,
                secure_flag,
                str(expires),
                name,
                value,
            )
        )
        lines.append(line)
    return lines


def write_lines(path: Path, lines: List[str], append: bool) -> None:
    mode = "a" if append and path.exists() else "w"
    with path.open(mode, encoding="utf-8") as handle:
        if mode == "a" and lines and not lines[0].startswith("#"):
            handle.write("\n")
        handle.write("\n".join(lines))
        handle.write("\n")


def main() -> None:
    args = parse_args()
    input_path = Path(args.input).expanduser()
    output_path = Path(args.output).expanduser()

    cookies = load_json(input_path)
    lines = to_netscape_lines(cookies)
    if len(lines) <= 2:
        raise RuntimeError("Не удалось создать ни одного cookie. Проверьте входной файл.")
    if not args.append and output_path.exists():
        print(f"Перезаписываем {output_path}")
    write_lines(output_path, lines, append=args.append)
    print(f"Сохранено {len(lines) - 2} cookie(ов) в {output_path}")


if __name__ == "__main__":
    main()
